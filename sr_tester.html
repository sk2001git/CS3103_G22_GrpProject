<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H-UDP GameNetAPI Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 0.85em;
            font-weight: 600;
            color: #495057;
        }
        
        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-danger:hover {
            background: #e53e3e;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        .panel {
            border: 2px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .panel-header {
            background: #f8f9fa;
            padding: 12px 15px;
            font-weight: 600;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .channel-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
        }
        
        .badge-reliable {
            background: #4299e1;
            color: white;
        }
        
        .badge-unreliable {
            background: #ed8936;
            color: white;
        }
        
        .panel-body {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .visualization {
            grid-column: 1 / -1;
            min-height: 300px;
        }
        
        .timeline {
            position: relative;
            height: 250px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px;
            overflow: hidden;
        }
        
        .packet {
            position: absolute;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .packet-reliable-sent {
            background: #4299e1;
            color: white;
        }
        
        .packet-unreliable-sent {
            background: #ed8936;
            color: white;
        }
        
        .packet-acked {
            background: #48bb78;
            color: white;
        }
        
        .packet-lost {
            background: #f56565;
            color: white;
        }
        
        .packet-retransmit {
            background: #e53e3e;
            color: white;
            border: 3px solid #c53030;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-card.reliable {
            border-left-color: #4299e1;
        }
        
        .stat-card.unreliable {
            border-left-color: #ed8936;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #212529;
        }
        
        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
        }
        
        .log-send-reliable {
            background: #e6f2ff;
            border-left: 3px solid #4299e1;
        }
        
        .log-send-unreliable {
            background: #fff3e6;
            border-left: 3px solid #ed8936;
        }
        
        .log-recv-reliable {
            background: #e6ffe6;
            border-left: 3px solid #48bb78;
        }
        
        .log-recv-unreliable {
            background: #fff9e6;
            border-left: 3px solid #f6ad55;
        }
        
        .log-ack {
            background: #e6ffe6;
            border-left: 3px solid #48bb78;
        }
        
        .log-drop {
            background: #ffe6e6;
            border-left: 3px solid #f56565;
        }
        
        .log-reorder {
            background: #f3e6ff;
            border-left: 3px solid #9f7aea;
        }
        
        .test-results {
            grid-column: 1 / -1;
        }
        
        .test-case {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #6c757d;
        }
        
        .test-case.passed {
            border-left-color: #48bb78;
            background: #f0fdf4;
        }
        
        .test-case.failed {
            border-left-color: #f56565;
            background: #fef2f2;
        }
        
        .test-case-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .test-case-title {
            font-weight: 600;
            font-size: 0.95em;
        }
        
        .test-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }
        
        .badge-pass {
            background: #48bb78;
            color: white;
        }
        
        .badge-fail {
            background: #f56565;
            color: white;
        }
        
        .test-details {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .channel-separator {
            grid-column: 1 / -1;
            text-align: center;
            padding: 15px;
            background: #e9ecef;
            font-weight: 600;
            color: #495057;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ H-UDP GameNetAPI Tester</h1>
            <p>Hybrid Transport Protocol Testing & Visualization (Reliable + Unreliable Channels)</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Packet Loss Rate (%)</label>
                <input type="number" id="lossRate" min="0" max="100" value="10" />
            </div>
            <div class="control-group">
                <label>Network Delay (ms)</label>
                <input type="number" id="delay" min="0" max="500" value="50" />
            </div>
            <div class="control-group">
                <label>Delay Jitter (ms)</label>
                <input type="number" id="jitter" min="0" max="200" value="20" />
            </div>
            <div class="control-group">
                <label>Reliable %</label>
                <input type="number" id="reliablePercent" min="0" max="100" value="50" />
            </div>
            <div class="control-group">
                <label>Skip Threshold (ms)</label>
                <input type="number" id="skipThreshold" min="100" max="2000" value="200" />
            </div>
            <div class="control-group">
                <label>Test Scenario</label>
                <select id="scenario">
                    <option value="mixed">Mixed Traffic (50/50)</option>
                    <option value="mostly-reliable">Mostly Reliable (80%)</option>
                    <option value="mostly-unreliable">Mostly Unreliable (80%)</option>
                    <option value="high-loss">High Loss (30%)</option>
                    <option value="reordering">Packet Reordering</option>
                    <option value="burst-loss">Burst Loss</option>
                    <option value="all">Run All Tests</option>
                </select>
            </div>
            <button class="btn-primary" onclick="runTest()">‚ñ∂ Run Test</button>
            <button class="btn-danger" onclick="stopTest()">‚èπ Stop</button>
            <button class="btn-success" onclick="clearLogs()">üóë Clear Logs</button>
        </div>
        
        <div class="stats">
            <div class="channel-separator" style="grid-column: 1 / -1;">üìä Overall Metrics</div>
            
            <div class="stat-card">
                <div class="stat-label">Total Packets Sent</div>
                <div class="stat-value" id="statTotalSent">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Delivered</div>
                <div class="stat-value" id="statTotalDelivered">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Lost</div>
                <div class="stat-value" id="statTotalLost">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Overall Delivery Rate</div>
                <div class="stat-value" id="statOverallRate">0%</div>
            </div>
            
            <div class="channel-separator" style="grid-column: 1 / -1;">üîí Reliable Channel</div>
            
            <div class="stat-card reliable">
                <div class="stat-label">Reliable Sent</div>
                <div class="stat-value" id="statReliableSent">0</div>
            </div>
            <div class="stat-card reliable">
                <div class="stat-label">Reliable Delivered</div>
                <div class="stat-value" id="statReliableDelivered">0</div>
            </div>
            <div class="stat-card reliable">
                <div class="stat-label">Retransmissions</div>
                <div class="stat-value" id="statRetrans">0</div>
            </div>
            <div class="stat-card reliable">
                <div class="stat-label">Avg RTT (ms)</div>
                <div class="stat-value" id="statRTT">0</div>
            </div>
            <div class="stat-card reliable">
                <div class="stat-label">Reordered Packets</div>
                <div class="stat-value" id="statReordered">0</div>
            </div>
            
            <div class="channel-separator" style="grid-column: 1 / -1;">üöÄ Unreliable Channel</div>
            
            <div class="stat-card unreliable">
                <div class="stat-label">Unreliable Sent</div>
                <div class="stat-value" id="statUnreliableSent">0</div>
            </div>
            <div class="stat-card unreliable">
                <div class="stat-label">Unreliable Delivered</div>
                <div class="stat-value" id="statUnreliableDelivered">0</div>
            </div>
            <div class="stat-card unreliable">
                <div class="stat-label">Unreliable Loss Rate</div>
                <div class="stat-value" id="statUnreliableLoss">0%</div>
            </div>
            <div class="stat-card unreliable">
                <div class="stat-label">Avg Latency (ms)</div>
                <div class="stat-value" id="statUnreliableLatency">0</div>
            </div>
        </div>
        
        <div class="content">
            <div class="panel visualization">
                <div class="panel-header">
                    <span>üìä Live Packet Timeline</span>
                    <div>
                        <span class="channel-badge badge-reliable">Reliable</span>
                        <span class="channel-badge badge-unreliable">Unreliable</span>
                    </div>
                </div>
                <div class="timeline" id="timeline"></div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <span>üì§ Sender Log (GameNetAPI.send)</span>
                </div>
                <div class="panel-body" id="senderLog"></div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <span>üì• Receiver Log (GameNetAPI.recv)</span>
                </div>
                <div class="panel-body" id="receiverLog"></div>
            </div>
            
            <div class="panel test-results">
                <div class="panel-header">
                    <span>‚úì Test Results</span>
                    <span id="testProgress"></span>
                </div>
                <div class="panel-body" id="testResults"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== Protocol Implementation =====
        const RELIABLE = 0;
        const UNRELIABLE = 1;
        const ACK = 2;
        const HEADER_SIZE = 7;
        const ACK_SIZE = 3;
        
        const U16_MOD = 1 << 16;
        const U16_MASK = U16_MOD - 1;

        function u16(x) { return x & U16_MASK; }
        function u16_incr(x, inc = 1) { return (x + inc) & U16_MASK; }
        function u16_distance(start, end) { return (end - start) & U16_MASK; }
        function u16_in_window(seq, start, size) { return u16_distance(start, seq) < size; }
        
        function nowMs() { return Date.now(); }

        // Packet serialization
        function packHeader(channelType, seqNum) {
            const buf = new ArrayBuffer(HEADER_SIZE);
            const view = new DataView(buf);
            view.setUint8(0, channelType);
            view.setUint16(1, seqNum, false);
            view.setUint32(3, nowMs(), false);
            return new Uint8Array(buf);
        }

        function unpackHeader(data) {
            const view = new DataView(data.buffer, data.byteOffset, HEADER_SIZE);
            return {
                channelType: view.getUint8(0),
                seqNum: view.getUint16(1, false),
                timestampMs: view.getUint32(3, false)
            };
        }

        function packAck(ackSeq) {
            const buf = new ArrayBuffer(ACK_SIZE);
            const view = new DataView(buf);
            view.setUint8(0, ACK);
            view.setUint16(1, ackSeq, false);
            return new Uint8Array(buf);
        }

        function unpackAck(data) {
            const view = new DataView(data.buffer, data.byteOffset, ACK_SIZE);
            return view.getUint16(1, false);
        }

        // ===== SR Protocol Implementation =====
        class SRSender {
            constructor(options = {}) {
                this.windowSize = options.windowSize || 64;
                this.rtoMs = options.rtoMs || 200;
                this.maxRetries = options.maxRetries || 10;
                this.onSendRaw = options.onSendRaw || (() => {});
                this.onDrop = options.onDrop || (() => {});
                this.onRtt = options.onRtt || (() => {});
                this.clockMs = options.clockMs || nowMs;

                this.base = 0;
                this.nextSeq = 0;
                this.out = new Map();

                this.srtt = null;
                this.rttvar = null;
                this.rto = this.rtoMs;
                this.K = 4.0;
                this.alpha = 1.0 / 8.0;
                this.beta = 1.0 / 4.0;
                this.minRto = 50.0;
                this.maxRto = 4000.0;

                this.timerInterval = null;
            }

            start() {
                if (this.timerInterval) return;
                this.timerInterval = setInterval(() => this._timerCheck(), Math.max(5, this.rto / 4));
            }

            stop() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            send(payload) {
                if (this.out.size >= this.windowSize) return null;

                const seq = this.nextSeq;
                this.nextSeq = u16_incr(this.nextSeq);
                const now = this.clockMs();

                this.out.set(seq, {
                    seq,
                    payload,
                    firstSendMs: now,
                    lastSendMs: now,
                    retries: 0,
                    retransmitted: false
                });

                this.onSendRaw(seq, payload);
                return seq;
            }

            ack(ackSeq) {
                const now = this.clockMs();
                const item = this.out.get(ackSeq);
                
                if (item) {
                    this.out.delete(ackSeq);
                    
                    if (item.retries === 0) {
                        const rttSample = Math.max(0, now - item.lastSendMs);
                        this._updateRto(rttSample);
                        this.onRtt(ackSeq, rttSample);
                    }
                }

                while (this.base !== this.nextSeq && !this.out.has(this.base)) {
                    this.base = u16_incr(this.base);
                }
            }

            _updateRto(rttMs) {
                if (this.srtt === null) {
                    this.srtt = rttMs;
                    this.rttvar = rttMs / 2.0;
                } else {
                    this.rttvar = (1 - this.beta) * this.rttvar + this.beta * Math.abs(this.srtt - rttMs);
                    this.srtt = (1 - this.alpha) * this.srtt + this.alpha * rttMs;
                }
                this.rto = this.srtt + this.K * this.rttvar;
                this.rto = Math.max(this.minRto, Math.min(this.rto, this.maxRto));
            }

            _backoffRto() {
                this.rto = Math.min(this.rto * 2.0, this.maxRto);
            }

            _timerCheck() {
                const now = this.clockMs();
                const rtoMs = this.rto;
                const toResend = [];
                const toDrop = [];

                for (const [seq, item] of this.out.entries()) {
                    if (now - item.lastSendMs >= rtoMs) {
                        if (item.retries < this.maxRetries) {
                            item.retries++;
                            item.lastSendMs = now;
                            item.retransmitted = true;
                            toResend.push(item);
                        } else {
                            toDrop.push(seq);
                        }
                    }
                }

                for (const seq of toDrop) {
                    this.out.delete(seq);
                    this.onDrop(seq);
                }

                while (this.base !== this.nextSeq && !this.out.has(this.base)) {
                    this.base = u16_incr(this.base);
                }

                if (toResend.length > 0) {
                    this._backoffRto();
                    for (const item of toResend) {
                        this.onSendRaw(item.seq, item.payload);
                    }
                }
            }
        }

        class SRReceiver {
            constructor(deliverInOrder, sendAck, options = {}) {
                this.deliverInOrder = deliverInOrder;
                this.sendAck = sendAck;
                this.clockMs = options.clockMs || nowMs;
                this.windowSize = options.windowSize || 64;
                this.skipThresholdMs = options.skipThresholdMs || 200;
                this.maxBuffer = options.maxBuffer || (2 * this.windowSize);

                this.expected = 0;
                this.buffer = new Map();
                this.holeSinceMs = null;

                this.timerInterval = setInterval(() => this._timerCheck(), Math.max(10, this.skipThresholdMs / 5));
            }

            stop() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            onData(seq, payload) {
                this.sendAck(seq);

                if (!u16_in_window(seq, this.expected, this.windowSize)) {
                    return;
                }

                const deliverList = [];
                const now = this.clockMs();

                if (seq === this.expected) {
                    deliverList.push([seq, payload]);
                    this.expected = u16_incr(this.expected);
                    this.holeSinceMs = null;

                    while (this.buffer.has(this.expected)) {
                        const [p, _ts] = this.buffer.get(this.expected);
                        this.buffer.delete(this.expected);
                        deliverList.push([this.expected, p]);
                        this.expected = u16_incr(this.expected);
                        this.holeSinceMs = null;
                    }
                } else {
                    if (!this.buffer.has(seq) && this.buffer.size < this.maxBuffer) {
                        this.buffer.set(seq, [payload, now]);
                    }

                    if (!this.buffer.has(this.expected)) {
                        if (this.holeSinceMs === null) {
                            this.holeSinceMs = now;
                        }
                    } else {
                        this.holeSinceMs = null;
                    }
                }

                for (const [s, p] of deliverList) {
                    this.deliverInOrder(s, p);
                }
            }

            _timerCheck() {
                if (this.holeSinceMs !== null && this.skipThresholdMs > 0) {
                    if (this.clockMs() - this.holeSinceMs >= this.skipThresholdMs) {
                        this.expected = u16_incr(this.expected);
                        this.holeSinceMs = null;

                        const deliverList = [];
                        while (this.buffer.has(this.expected)) {
                            const [p, _ts] = this.buffer.get(this.expected);
                            this.buffer.delete(this.expected);
                            deliverList.push([this.expected, p]);
                            this.expected = u16_incr(this.expected);
                        }

                        if (!this.buffer.has(this.expected)) {
                            this.holeSinceMs = this.clockMs();
                        }

                        for (const [s, p] of deliverList) {
                            this.deliverInOrder(s, p);
                        }
                    }
                }
            }
        }

        // ===== GameNetAPI Implementation =====
        class GameNetAPI {
            constructor(skipThresholdMs = 200) {
                this.peerAddr = null;
                this.sendSeqReliable = 0;
                this.sendSeqUnreliable = 0;
                this.recvQueue = [];
                this.running = false;
                this.skipThresholdMs = skipThresholdMs;
                this.rxTs = new Map();
                
                this.networkSimulator = null;

                this.srSender = new SRSender({
                    windowSize: 64,
                    rtoMs: 200,
                    maxRetries: 10,
                    onSendRaw: (seq, payload) => this._srOnSendRaw(seq, payload),
                    onDrop: (seq) => this._srOnDrop(seq),
                    onRtt: (seq, rtt) => this._srOnRtt(seq, rtt),
                    clockMs: nowMs
                });

                this.srReceiver = new SRReceiver(
                    (seq, payload) => this._srDeliverInOrder(seq, payload),
                    (seq) => this._srSendAck(seq),
                    {
                        skipThresholdMs: skipThresholdMs,
                        clockMs: nowMs,
                        windowSize: 64
                    }
                );
            }

            start() {
                this.running = true;
                this.srSender.start();
            }

            stop() {
                this.running = false;
                this.srReceiver.stop();
                this.srSender.stop();
            }

            setPeer(addr) {
                this.peerAddr = addr;
            }

            attachNetworkSimulator(simulator) {
                this.networkSimulator = simulator;
            }

            send(payload, reliable) {
                if (!this.peerAddr) {
                    throw new Error("No peer address. Call setPeer() first.");
                }

                if (reliable) {
                    const seq = this.srSender.send(payload);
                    if (seq === null) {
                        return null; // Window full
                    }
                    return payload.length + HEADER_SIZE;
                } else {
                    const seqNum = this.sendSeqUnreliable;
                    this.sendSeqUnreliable = u16_incr(this.sendSeqUnreliable);
                    const header = packHeader(UNRELIABLE, seqNum);
                    const packet = new Uint8Array(header.length + payload.length);
                    packet.set(header);
                    packet.set(payload, header.length);
                    this._sendInternal(packet);
                    return payload.length + HEADER_SIZE;
                }
            }

            recv(block = true) {
                if (!block) {
                    return this.recvQueue.length > 0 ? this.recvQueue.shift() : null;
                }

                while (this.recvQueue.length === 0 && this.running) {
                    // In real implementation, would wait
                    return null;
                }
                return this.running ? this.recvQueue.shift() : null;
            }

            _sendInternal(data) {
                if (this.networkSimulator) {
                    this.networkSimulator.transmit(() => {
                        if (this.peerAddr) {
                            this._handleIncomingPacket(data);
                        }
                    });
                } else {
                    if (this.peerAddr) {
                        this._handleIncomingPacket(data);
                    }
                }
            }

            _srOnSendRaw(seq, payload) {
                if (!this.peerAddr) return;
                const header = packHeader(RELIABLE, seq);
                const packet = new Uint8Array(header.length + payload.length);
                packet.set(header);
                packet.set(payload, header.length);
                this._sendInternal(packet);
            }

            _srSendAck(ackSeq) {
                if (!this.peerAddr) return;
                const ackPacket = packAck(ackSeq);
                this._sendInternal(ackPacket);
            }

            _srDeliverInOrder(seq, payload) {
                const ts = this.rxTs.get(seq) || nowMs();
                this.rxTs.delete(seq);
                this.recvQueue.push({
                    channelType: RELIABLE,
                    seqNum: seq,
                    timestampMs: ts,
                    payload: payload
                });
            }

            _srOnDrop(seq) {
                // Optional: log dropped packets
            }

            _srOnRtt(seq, rttMs) {
                // Optional: collect RTT metrics
            }

            _handleIncomingPacket(data) {
                if (data.length === ACK_SIZE && data[0] === ACK) {
                    const ackSeq = unpackAck(data);
                    this.srSender.ack(ackSeq);
                } else if (data.length >= HEADER_SIZE) {
                    const header = unpackHeader(data.slice(0, HEADER_SIZE));
                    const payload = data.slice(HEADER_SIZE);

                    if (header.channelType === UNRELIABLE) {
                        this.recvQueue.push({
                            channelType: UNRELIABLE,
                            seqNum: header.seqNum,
                            timestampMs: header.timestampMs,
                            payload: payload
                        });
                    } else if (header.channelType === RELIABLE) {
                        this.rxTs.set(header.seqNum, header.timestampMs);
                        this.srReceiver.onData(header.seqNum, payload);
                    }
                }
            }
        }

        // ===== Network Simulator =====
        class NetworkSimulator {
            constructor(lossRate, delay, jitter) {
                this.lossRate = lossRate;
                this.delay = delay;
                this.jitter = jitter;
                this.reorderingEnabled = false;
                this.burstLossEnabled = false;
                this.burstLossCounter = 0;
                this.packetsSent = 0;
                this.packetsLost = 0;
            }

            transmit(callback) {
                this.packetsSent++;
                
                if (this.burstLossEnabled) {
                    if (this.burstLossCounter < 5) {
                        this.burstLossCounter++;
                        this.packetsLost++;
                        return;
                    } else if (this.burstLossCounter < 10) {
                        this.burstLossCounter++;
                    } else {
                        this.burstLossCounter = 0;
                        this.burstLossEnabled = false;
                    }
                }

                if (Math.random() * 100 < this.lossRate) {
                    this.packetsLost++;
                    return;
                }

                const actualDelay = this.delay + (Math.random() - 0.5) * this.jitter * 2;

                if (this.reorderingEnabled && Math.random() < 0.3) {
                    setTimeout(callback, actualDelay + Math.random() * 100);
                } else {
                    setTimeout(callback, Math.max(0, actualDelay));
                }
            }
        }

        // ===== Test Framework =====
        let testState = {
            running: false,
            senderAPI: null,
            receiverAPI: null,
            network: null,
            stats: {
                reliableSent: 0,
                unreliableSent: 0,
                reliableDelivered: 0,
                unreliableDelivered: 0,
                totalLost: 0,
                retrans: 0,
                reordered: 0,
                rttSamples: [],
                unreliableLatencies: [],
                reliableSeqs: new Set(),
                unreliableSeqs: new Set(),
                deliveredReliableSeqs: new Set(),
                deliveredUnreliableSeqs: new Set(),
                lastReliableDelivered: -1
            }
        };

        function addLog(type, message, logId) {
            const log = document.getElementById(logId);
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.insertBefore(entry, log.firstChild);
            if (log.children.length > 100) log.removeChild(log.lastChild);
        }

        function updateStats() {
            document.getElementById('statReliableSent').textContent = testState.stats.reliableSent;
            document.getElementById('statUnreliableSent').textContent = testState.stats.unreliableSent;
            document.getElementById('statReliableDelivered').textContent = testState.stats.reliableDelivered;
            document.getElementById('statUnreliableDelivered').textContent = testState.stats.unreliableDelivered;
            document.getElementById('statTotalSent').textContent = testState.stats.reliableSent + testState.stats.unreliableSent;
            document.getElementById('statTotalDelivered').textContent = testState.stats.reliableDelivered + testState.stats.unreliableDelivered;
            document.getElementById('statTotalLost').textContent = testState.stats.totalLost;
            document.getElementById('statRetrans').textContent = testState.stats.retrans;
            document.getElementById('statReordered').textContent = testState.stats.reordered;
            
            const avgRtt = testState.stats.rttSamples.length > 0
                ? Math.round(testState.stats.rttSamples.reduce((a, b) => a + b, 0) / testState.stats.rttSamples.length)
                : 0;
            document.getElementById('statRTT').textContent = avgRtt;
            
            const avgUnreliableLatency = testState.stats.unreliableLatencies.length > 0
                ? Math.round(testState.stats.unreliableLatencies.reduce((a, b) => a + b, 0) / testState.stats.unreliableLatencies.length)
                : 0;
            document.getElementById('statUnreliableLatency').textContent = avgUnreliableLatency;
            
            const totalSent = testState.stats.reliableSent + testState.stats.unreliableSent;
            const totalDelivered = testState.stats.reliableDelivered + testState.stats.unreliableDelivered;
            const overallRate = totalSent > 0 ? Math.round((totalDelivered / totalSent) * 100) : 0;
            document.getElementById('statOverallRate').textContent = overallRate + '%';
            
            const unreliableLoss = testState.stats.unreliableSent > 0
                ? Math.round(((testState.stats.unreliableSent - testState.stats.unreliableDelivered) / testState.stats.unreliableSent) * 100)
                : 0;
            document.getElementById('statUnreliableLoss').textContent = unreliableLoss + '%';
        }

        function visualizePacket(seq, type, channelType) {
            const timeline = document.getElementById('timeline');
            const packet = document.createElement('div');
            packet.className = `packet packet-${channelType}-${type}`;
            packet.textContent = seq;
            
            const x = (seq % 30) * 40 + 20;
            const y = Math.floor(seq / 30) * 50 + 20;
            
            packet.style.left = x + 'px';
            packet.style.top = (y % 200) + 'px';
            
            timeline.appendChild(packet);
            
            setTimeout(() => {
                if (packet.parentNode) packet.parentNode.removeChild(packet);
            }, 2000);
        }

        async function runTest() {
            if (testState.running) return;
            
            testState.running = true;
            testState.stats = {
                reliableSent: 0,
                unreliableSent: 0,
                reliableDelivered: 0,
                unreliableDelivered: 0,
                totalLost: 0,
                retrans: 0,
                reordered: 0,
                rttSamples: [],
                unreliableLatencies: [],
                reliableSeqs: new Set(),
                unreliableSeqs: new Set(),
                deliveredReliableSeqs: new Set(),
                deliveredUnreliableSeqs: new Set(),
                lastReliableDelivered: -1
            };

            const lossRate = parseFloat(document.getElementById('lossRate').value);
            const delay = parseFloat(document.getElementById('delay').value);
            const jitter = parseFloat(document.getElementById('jitter').value);
            const reliablePercent = parseFloat(document.getElementById('reliablePercent').value) / 100;
            const skipThreshold = parseInt(document.getElementById('skipThreshold').value);
            const scenario = document.getElementById('scenario').value;

            testState.network = new NetworkSimulator(lossRate, delay, jitter);

            // Configure scenario
            if (scenario === 'high-loss') {
                testState.network.lossRate = 30;
            } else if (scenario === 'reordering') {
                testState.network.reorderingEnabled = true;
            } else if (scenario === 'burst-loss') {
                testState.network.burstLossEnabled = true;
            } else if (scenario === 'mostly-reliable') {
                // Will be handled in send loop
            } else if (scenario === 'mostly-unreliable') {
                // Will be handled in send loop
            }

            // Initialize APIs
            testState.senderAPI = new GameNetAPI(skipThreshold);
            testState.receiverAPI = new GameNetAPI(skipThreshold);
            
            testState.senderAPI.attachNetworkSimulator(testState.network);
            testState.senderAPI.setPeer('receiver');
            testState.receiverAPI.setPeer('sender');
            
            // Override sender's send to track stats
            const originalSrOnSendRaw = testState.senderAPI._srOnSendRaw.bind(testState.senderAPI);
            testState.senderAPI._srOnSendRaw = (seq, payload) => {
                const isRetrans = testState.stats.reliableSeqs.has(seq);
                if (isRetrans) {
                    testState.stats.retrans++;
                    addLog('send-reliable', `‚ü≥ Retransmit R-${seq}`, 'senderLog');
                    visualizePacket(seq, 'retransmit', 'reliable');
                } else {
                    addLog('send-reliable', `‚Üí Send R-${seq} "${new TextDecoder().decode(payload)}"`, 'senderLog');
                    visualizePacket(seq, 'sent', 'reliable');
                }
                originalSrOnSendRaw(seq, payload);
                updateStats();
            };

            // Override receiver to track deliveries
            const originalHandleIncoming = testState.receiverAPI._handleIncomingPacket.bind(testState.receiverAPI);
            testState.receiverAPI._handleIncomingPacket = (data) => {
                originalHandleIncoming(data);
                
                // Process received packets from queue
                while (testState.receiverAPI.recvQueue.length > 0) {
                    const packet = testState.receiverAPI.recvQueue.shift();
                    const payload = new TextDecoder().decode(packet.payload);
                    const latency = nowMs() - packet.timestampMs;
                    
                    if (packet.channelType === RELIABLE) {
                        testState.stats.reliableDelivered++;
                        testState.stats.deliveredReliableSeqs.add(packet.seqNum);
                        
                        // Check for reordering
                        if (testState.stats.lastReliableDelivered >= 0 && 
                            packet.seqNum < testState.stats.lastReliableDelivered) {
                            testState.stats.reordered++;
                            addLog('reorder', `‚ö† Out-of-order R-${packet.seqNum} (last: ${testState.stats.lastReliableDelivered})`, 'receiverLog');
                        }
                        testState.stats.lastReliableDelivered = packet.seqNum;
                        
                        addLog('recv-reliable', `‚úì Deliver R-${packet.seqNum} "${payload}" (${latency}ms)`, 'receiverLog');
                        visualizePacket(packet.seqNum, 'acked', 'reliable');
                    } else {
                        testState.stats.unreliableDelivered++;
                        testState.stats.deliveredUnreliableSeqs.add(packet.seqNum);
                        testState.stats.unreliableLatencies.push(latency);
                        addLog('recv-unreliable', `‚Üí Receive U-${packet.seqNum} "${payload}" (${latency}ms)`, 'receiverLog');
                        visualizePacket(packet.seqNum, 'sent', 'unreliable');
                    }
                    updateStats();
                }
            };

            testState.senderAPI.start();
            testState.receiverAPI.start();

            // Send test data
            const numPackets = scenario === 'all' ? 50 : 40;
            const actualReliablePercent = scenario === 'mostly-reliable' ? 0.8 :
                                         scenario === 'mostly-unreliable' ? 0.2 :
                                         reliablePercent;
            
            for (let i = 0; i < numPackets; i++) {
                await new Promise(resolve => setTimeout(resolve, 30));
                if (!testState.running) break;
                
                const isReliable = Math.random() < actualReliablePercent;
                const payload = new TextEncoder().encode(`${isReliable ? 'GAME_STATE' : 'PLAYER_POS'}_${i}`);
                
                const result = testState.senderAPI.send(payload, isReliable);
                
                if (result !== null) {
                    if (isReliable) {
                        testState.stats.reliableSent++;
                        testState.stats.reliableSeqs.add(testState.senderAPI.srSender.nextSeq - 1);
                    } else {
                        testState.stats.unreliableSent++;
                        testState.stats.unreliableSeqs.add(testState.senderAPI.sendSeqUnreliable - 1);
                        addLog('send-unreliable', `‚Üí Send U-${testState.senderAPI.sendSeqUnreliable - 1} "${new TextDecoder().decode(payload)}"`, 'senderLog');
                    }
                } else {
                    addLog('drop', `‚úó Window full, packet dropped`, 'senderLog');
                    testState.stats.totalLost++;
                }
                updateStats();
            }

            // Wait for completion
            await new Promise(resolve => setTimeout(resolve, 5000));

            // Run assertions
            await runAssertions(scenario);

            testState.running = false;
        }

        async function runAssertions(scenario) {
            const results = document.getElementById('testResults');
            results.innerHTML = '';

            const tests = [
                {
                    name: 'All reliable packets delivered or dropped',
                    test: () => {
                        const total = testState.stats.reliableDelivered;
                        const expected = testState.stats.reliableSent;
                        return {
                            passed: total >= expected * 0.7, // Allow some drops due to max retries
                            details: `Sent: ${expected}, Delivered: ${total} (${(total/expected*100).toFixed(1)}%)`
                        };
                    }
                },
                {
                    name: 'No duplicate reliable deliveries',
                    test: () => {
                        const unique = testState.stats.deliveredReliableSeqs.size;
                        const total = testState.stats.reliableDelivered;
                        return {
                            passed: unique === total,
                            details: `Unique: ${unique}, Total: ${total}`
                        };
                    }
                },
                {
                    name: 'Reliable packets delivered in order',
                    test: () => {
                        return {
                            passed: testState.stats.reordered === 0,
                            details: `Out-of-order deliveries: ${testState.stats.reordered}`
                        };
                    }
                },
                {
                    name: 'Unreliable packets delivered (best effort)',
                    test: () => {
                        const rate = testState.stats.unreliableSent > 0
                            ? (testState.stats.unreliableDelivered / testState.stats.unreliableSent)
                            : 1;
                        return {
                            passed: true, // Always pass - unreliable is best effort
                            details: `Sent: ${testState.stats.unreliableSent}, Delivered: ${testState.stats.unreliableDelivered} (${(rate*100).toFixed(1)}%)`
                        };
                    }
                },
                {
                    name: 'RTT measurements collected',
                    test: () => {
                        const hasRtt = testState.stats.rttSamples.length > 0;
                        const avgRtt = hasRtt ? testState.stats.rttSamples.reduce((a,b)=>a+b,0)/testState.stats.rttSamples.length : 0;
                        return {
                            passed: testState.stats.reliableSent === 0 || hasRtt,
                            details: `RTT samples: ${testState.stats.rttSamples.length}, Avg: ${avgRtt.toFixed(1)}ms`
                        };
                    }
                },
                {
                    name: 'Retransmissions occurred (if losses)',
                    test: () => {
                        const hasLoss = testState.network.packetsLost > 0;
                        const hasRetrans = testState.stats.retrans > 0;
                        return {
                            passed: !hasLoss || hasRetrans,
                            details: `Network losses: ${testState.network.packetsLost}, Retransmissions: ${testState.stats.retrans}`
                        };
                    }
                },
                {
                    name: 'Overall delivery rate acceptable',
                    test: () => {
                        const total = testState.stats.reliableSent + testState.stats.unreliableSent;
                        const delivered = testState.stats.reliableDelivered + testState.stats.unreliableDelivered;
                        const rate = total > 0 ? (delivered / total) * 100 : 0;
                        const minRate = scenario === 'high-loss' ? 50 : 70;
                        return {
                            passed: rate >= minRate,
                            details: `Delivery rate: ${rate.toFixed(1)}% (min: ${minRate}%)`
                        };
                    }
                },
                {
                    name: 'Channel separation maintained',
                    test: () => {
                        const reliableOverlap = Array.from(testState.stats.deliveredReliableSeqs)
                            .some(seq => testState.stats.deliveredUnreliableSeqs.has(seq));
                        return {
                            passed: !reliableOverlap,
                            details: `Reliable and unreliable channels properly separated`
                        };
                    }
                }
            ];

            let passed = 0;
            let failed = 0;

            for (const test of tests) {
                const result = test.test();
                if (result.passed) passed++;
                else failed++;

                const testCase = document.createElement('div');
                testCase.className = `test-case ${result.passed ? 'passed' : 'failed'}`;
                testCase.innerHTML = `
                    <div class="test-case-header">
                        <span class="test-case-title">${test.name}</span>
                        <span class="test-badge ${result.passed ? 'badge-pass' : 'badge-fail'}">
                            ${result.passed ? '‚úì PASS' : '‚úó FAIL'}
                        </span>
                    </div>
                    <div class="test-details">${result.details}</div>
                `;
                results.appendChild(testCase);
            }

            const progress = document.getElementById('testProgress');
            progress.textContent = `${passed}/${tests.length} passed`;
            progress.style.color = failed === 0 ? '#48bb78' : '#f56565';
        }

        function stopTest() {
            testState.running = false;
            if (testState.senderAPI) {
                testState.senderAPI.stop();
                testState.senderAPI = null;
            }
            if (testState.receiverAPI) {
                testState.receiverAPI.stop();
                testState.receiverAPI = null;
            }
            addLog('send-reliable', '‚èπ Test stopped', 'senderLog');
            addLog('recv-reliable', '‚èπ Test stopped', 'receiverLog');
        }

        function clearLogs() {
            document.getElementById('senderLog').innerHTML = '';
            document.getElementById('receiverLog').innerHTML = '';
            document.getElementById('timeline').innerHTML = '';
            document.getElementById('testResults').innerHTML = '';
        }

        window.addEventListener('beforeunload', () => {
            stopTest();
        });
    </script>
</body>
</html>